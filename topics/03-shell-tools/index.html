<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>/topics/03-shell-tools [missing course]</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>
  pre code {
      background-color: lightgoldenrodyellow;
      border-radius: 1.0rem;
      display: block;
      font-size: 0.8rem;
      padding: 1.0rem;
  }

  pre code.sourceCode {
      background-color: lightgoldenrodyellow;
  }

  code {
      background-color: lightgoldenrodyellow;
      border-radius: 0.3rem;
      padding: 0.1rem 0.2rem;
  }

  figcaption {
      font-size: 0.9rem;
      font-style: italic;
      text-align: center;
  }

  #before {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid black;
  }

  #after {
      display: flex;
      justify-content: space-between;
      border-top: 1px solid black;
  }
  </style>
</head>
<body>
<div id="banner">
    <img src="media/header.jpg" alt="Course Header">
</div>
<div id="before">
    The Missing Course
    <div id="before-links">
        <a href="../.." title="Course Home">Home</a> |
        <a href="https://github.com/glesica/missing-course" title="Course GitHub Page">GitHub</a>
    </div>
</div>
<h1 id="shell-tools">Shell Tools</h1>
<ul>
<li><a href="https://missing.csail.mit.edu/2020/shell-tools/">MIT Page</a> (second half)</li>
</ul>
<p>There exists a plethora of useful command line tools. We’re going to take a look at a few that are likely to be helpful as you work your way through school and begin a career as a computer scientist or software developer.</p>
<h2 id="history">History</h2>
<p>Remember that complicated command you used to do that complicated thing the other day? Yeah, no one does. That’s why we have <code>Ctrl-R</code>. This allows you to easily find a command you’ve run in the past to (optionally) edit and run again.</p>
<ul>
<li><a href="https://youtu.be/Hj6Us07MTRM">Example Video</a></li>
</ul>
<p>There is also a command called <code>history</code> that will simply print a list of your past commands. This can be useful if you want to copy-paste commands into a document or otherwise make use of your history in ways other than running a single command.</p>
<h2 id="navigate-and-browse">Navigate and Browse</h2>
<ul>
<li><a href="https://linux.die.net/man/1/tree">Tree</a></li>
<li><a href="https://github.com/wting/autojump">Autojump</a></li>
<li><a href="https://github.com/clvv/fasd">Fasd</a></li>
</ul>
<p>We already looked at <code>cd</code>, <code>ls</code>, and <code>pwd</code> for navigating the filesystem, but there are a few other commands that can make life easier.</p>
<h3 id="tree">Tree</h3>
<p>This command, which will need to be installed on most systems (you can use <code>brew install tree</code> on a Mac), prints a directory hierarchy as a pleasant ASCII art diagram. For example, running it on this repository directory:</p>
<pre><code>missing-course on  master [!]
➜ tree .
.
├── AUTHORS
├── LICENSE
├── Makefile
├── README.md
├── index.html
├── media
│   ├── header.html
│   ├── header.jpg
│   └── videos
│       └── ctrl-r-demo.mov
└── topics
    ├── 01-shell-overview
    │   ├── README.md
    │   └── index.html
    ├── 02-shell-scripting
    │   ├── README.md
    │   └── index.html
    ├── 03-shell-tools
    │   ├── README.md
    │   └── index.html
    ├── README.md
    └── index.html

6 directories, 16 files</code></pre>
<h3 id="stack-commands">Stack Commands</h3>
<p>The <code>pushd</code> and <code>popd</code> commands allow you to create a stack of directories so that you can retrace your steps back to your starting position.</p>
<pre><code># Assume we start in the home directory
cd

# Time to work on some code
cd Code/awesome-project

# Go update the paper we&#39;re writing about this project
pushd ~/Documents/awesome-project-paper

# Jump back to the code without typing the directory again
popd</code></pre>
<h3 id="fasd-and-autojump">Fasd and Autojump</h3>
<p><a href="https://github.com/clvv/fasd">Fasd</a> and <a href="https://github.com/wting/autojump">Autojump</a> allow the user to navigate to directories they have previously visited using “fuzzy” matching and the concept of “frecency” (frequency combined with recent). For example, starting in my home directory I can jump all the way into the directory belonging to a particular project (that I work on semi-regularly) simply by providing the name of the project’s directory (or even part of it). Note that <code>j</code> here is an alias that runs autojump with the correct arguments.</p>
<pre><code>~ $ # We start in the home directory
~ $ j polyA
~/Code/TravisWheelerLab/polyA $ # Now we&#39;re here!</code></pre>
<h2 id="grep-and-friends">Grep and Friends</h2>
<ul>
<li><a href="https://github.com/ggreer/the_silver_searcher">The Silver Searcher</a></li>
<li><a href="https://github.com/BurntSushi/ripgrep">Ripgrep</a></li>
</ul>
<p>Grep can find occurrences of a specific string or regular expression within text files.</p>
<pre><code># Find &quot;Missing&quot; in the file README.md
grep Missing README.md`

# Find &quot;command&quot; in all files under the current directory, recursively
grep -r Missing .

# Only print filenames, not the line that matched
grep -lr command .

# Print some context around each match (2 lines)
grep -r -C2 command .

# Print filenames that did not match
grep -rL Missing .</code></pre>
<h3 id="history-redux">History Redux</h3>
<p>Remember the <code>history</code> command? We can use a Unix pipe along with grep to find all similar commands we’ve run in the past. For example, sometimes it is useful to recall which packages have been installed through Homebrew. The following command can find all invocations of <code>brew install</code>:</p>
<pre><code>history | grep &quot;brew install&quot;</code></pre>
<h3 id="silver-searcher-and-ripgrep">Silver Searcher and Ripgrep</h3>
<p>These tools act a lot like Grep, but provide better performance and other features that make them more pleasant to use. For example, they can respect your version control system’s “ignore” file to avoid generating extra, useless results.</p>
<pre><code>ag &quot;search term&quot;</code></pre>
<h2 id="find">Find</h2>
<p>We’ve talked a lot about how to navigate the file system and work with files, but what about finding files based on their name or other characteristics? For this, we have the <code>find</code> command.</p>
<pre><code>find . -name myfile

# We can also filter by type, which is often useful
# for limiting our results to only regular files
# (excluding directories and symlinks, for example).
find . -type f -name myfile

# It is also possible to negate filters. The command
# below finds all files that do not have a .py
# extension.
find . -type f ! -name &#39;*.py&#39;</code></pre>
<p>It is also possible to have find run a command on each file it finds. This can be helpful if you want to run a command against several different files to produce an output for each.</p>
<pre><code># Run the mypy type checker against all Python files
# found in or below the current directory.
find . -type f -name &#39;*.py&#39; -exec mypy {} \;</code></pre>
<h2 id="parallelize-commands">Parallelize Commands</h2>
<ul>
<li><a href="https://www.gnu.org/software/parallel/">GNU Parallel</a></li>
<li><a href="https://www.usenix.org/system/files/login/articles/105438-Tange.pdf">GNU Parallel Tutorial</a></li>
</ul>
<p>You might notice that the <code>find</code> command above takes a few seconds if there are many Python files. That’s partly because mypy is run against each file in serial. We could speed things up by running mypy in parallel and we can use the <code>parallel</code> command to do it. Note: this is another one of those commands you’ll probably have to install, it doesn’t ship with most systems.</p>
<p>Let’s play around a bit…</p>
<pre><code># Create a bunch of empty files
touch file-{001..100}.txt

# Put some data in each file, in this case
# just a bunch of words
find . -name &#39;*.txt&#39; -exec sh -c &quot;head -100000 /usr/share/dict/words &gt; {}&quot; \;

# Use find to compress all of the files
# and time how long it takes, then decompress
time find . -name &#39;*.txt&#39; -exec gzip {} \;
time find . -name &#39;*.gz&#39; -exec gunzip {} \;

# Use parallel to compress all of the files
# and time how long it takes, then decompress
time parallel gzip ::: *.txt
time parallel gunzip ::: *.gz</code></pre>
<p>You’ll notice that there wasn’t much difference, that’s because our task is mostly I/O bound anyway, but take a look at the CPU percentage, you can tell the tasks are being parallelized because the CPU usage is much higher in the second version.</p>
<p>Now let’s create a more complicated example that should actually result in better performance when we parallelize the work. This is still going to be rather contrived, but it shouldn’t be hard to imagine how it could be translated to real work.</p>
<p>First, we’ll write a program that does something CPU bound. Then we’ll want a quick script to create bogus data for that program to operate on.</p>
<ul>
<li><a href="is_prime.py">is_prime.py</a> - <code>./is_prime.py &lt;file&gt;</code></li>
<li><a href="random_numbers.py">random_numbers.py</a> - <code>./random_numbers.py &lt;N&gt; &lt;size&gt;</code></li>
</ul>
<p>Now let’s try the same thing we did above, compare the performance of <code>find</code> and <code>parallel</code>.</p>
<pre><code>mkdir scratch
cd scratch
touch numbers-{00..20}.txt
find . -name &#39;*.txt&#39; -exec sh -c &quot;../random_numbers.py 10 24 &gt; {}&quot; \;

time find . -name &#39;*.txt&#39; -exec ../is_prime.py {} \;
time parallel ../is_prime.py ::: *.txt</code></pre>
<p>You should see that <code>parallel</code> is quite a bit faster now that our work is CPU bound. On my machine, <code>find</code> takes about 35 seconds and <code>parallel</code> takes about 8 seconds.</p>
<h3 id="using-a-remote-machine">Using a Remote Machine</h3>
<p>Parallel can also run jobs on remote computers. We’ll take a quick look at that using the example above, but with a few more files to make it worthwhile given that everything is going to have to move over the network, taking up additional “wall clock” time.</p>
<p>A couple things to note. We use <code>--transfer</code> to tell Parallel that we want to move the files to be processed to the remote machine before running. The <code>--cleanup</code> option, correspondingly, tells it to delete those files after it is finished. The <code>-j10</code> options tells Parallel to run 10 jobs at the same time, this requires using SSH to log into the remote system 10 times.</p>
<p>You won’t be able to run this examples as-is since you don’t have access to the remote machine or my SSH configuration. Later in the semester we’re going to talk about using SSH and we will create remote servers using a service called AWS. At that point, we can revisit this example.</p>
<pre><code># First, we need to copy over the program we&#39;re going to run
scp ../is_prime.py bioinfo:~/

# Now we can run it!
time parallel -j10 -S bioinfo --transfer --cleanup ./is_prime.py ::: *.txt</code></pre>
<p>Notice that the output produced by <code>time</code> is a little less useful since we don’t particularly care how much CPU time was used, only the “wall clock” time matters at this point.</p>
<h3 id="monitor-cpu-usage">Monitor CPU Usage</h3>
<p>We can use the <code>htop</code> tool (which can be installed through Homebrew or your Linux package manager) to monitor CPU usage while we run a parallel task. We could also use the <code>top</code> tool, which is included in virtually all Unix-like operating systems, but <code>htop</code> is way cooler.</p>
<p>Note that you have to run <code>htop</code> using <code>sudo htop</code> on a Mac (this runs it as the “root” user). On Linux just <code>htop</code> will suffice.</p>
<p>In one terminal window, start up <code>htop</code>. It will look something like the image below. Note that you can press “Q” to quit.</p>
<figure>
<img src="media/03-htop.png" alt="Running htop" /><figcaption aria-hidden="true">Running htop</figcaption>
</figure>
<p>Then, in another terminal window, run one of the commands below and watch what happens in your <code>htop</code> window. When you run the first one, you’ll notice that one of your CPUs (which one may change over time) goes up to about 100% usage. For the second command, you’ll see several of them pegged around 100%. That’s because Parallel is running multiple jobs at the same time.</p>
<pre><code>time find . -name &#39;*.txt&#39; -exec ../is_prime.py {} \;
time parallel ../is_prime.py ::: *.txt</code></pre>

<div id="after">
    <a href="#">Back to top</a>
    <div id="after-links">
        <a href="../.." title="Course Home">Home</a> |
        <a href="https://github.com/glesica/missing-course" title="Course GitHub Page">GitHub</a>
    </div>
</div>
</body>
</html>
